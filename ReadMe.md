### ***游戏demo简介：***

&nbsp;	这是一个3D解密游戏场景，玩家操控角色在场景中解开谜题从而获得离开的方法。

### ***脚本设计框架：***

&nbsp;	游戏由场景和物体构成，由事件进行驱动，简单分析一下，这个解谜场景涉及的事件包括机关的移动，角色的传送，玩家通过关卡，提示解谜进度等事件

于是用一个脚本TempleEvents来统一管理在其中定义委托。

&nbsp;	有了事件委托，那么必须要有对应的事物去订阅，那么考虑场景中的事物，包括角色，机关A，机关B，围栏，传送起始点，传送终点，机关触发点等等，决

定用脚本GameManger来统一管理游戏中的事物并向委托发起订阅

&nbsp;	事件有了，订阅有了，那么接下来肯定就需要发布委托，考虑使用Triggers触发器来发布对应的事件委托，根据事件的不同大致可分为三类触发器：传送点

触发器，机器触发器，状态触发器。

&nbsp;	注意到上方出现了“状态触发器”，在此解释为何会出现这个概念，由于玩家是否通过是一个较抽象概念，我们要转化为具体的，可操控，可编写的代码，于是

尝试用状态来表示玩家的解谜进度，例如解开了谜底A则A的状态设置为True。由此，我们需要编写TempleStates脚本来进行改变和设置机关的状态。

&nbsp;	对于玩家操控的角色只需编写对应的移动脚本即可。

### ***脚本实现细节：***

&nbsp;	TempleEvents脚本需要对会发生的事件进行定义，由于触发器会发布委托，为了方便调用，将所有在该脚本中定义的委托设置为static，方便通过类名直接进行

访问。

&nbsp;	GameManger脚本需要将demo中会对事件做出响应的事物进行定义，注意定义时权限设置为public方便访问和绑定(在unity的Inspector面板中)，另外对于

订阅委托，建议写在Start中，在游戏开始之初就行订阅，对不同的事件书写对应的函数。

&nbsp;	TempleStates脚本一定要理解该脚本只是一个抽象的描述和设置物体的状态的脚本，他并不直接改变游戏物体而是对脱离的，抽象出来的，物体的状态进行描述

和设置，所以在该脚本中需要书写对需要描述和改变状态的事物的对应的改变状态的函数，注意，在每次调用该函数后都应该检测玩家是否通关，避免错过。

&nbsp;	Triggers脚本一定要把握思想来进行编写：“我”是事件的发布者。利用OnTriggerEnter类函数来实现对应的功能即可

&nbsp;	Player脚本在编写时一定要区分Space.Self和Space.World，该demo只需实现简单的移动和转向功能。

### ***踩过的坑：***

&nbsp;	Player的移动要用if，而不是if-else if,因为角色的移动可以同时朝多个方向移动！！！

&nbsp;	一定要在每次设置机关状态后都判断一下玩家是否通关！！！

&nbsp;	Player的碰撞体体积一定要设置，不然无法触发一些触发器！！！

&nbsp;	物体的tag一定要和脚本中使用的一样，区分大小写！！！

### ***小Tips***

&nbsp;	对于某些复杂结构物体，可以将其中某个部件作为父亲，只设置父亲的碰撞体体积，删除儿子的碰撞体组件可以节约性能。

&nbsp;	静态物体设置成静态，光照渲染时采用mix模式，节约性能

&nbsp;	将脚本中某些变量设置成public，可以方便的在Inspector面板中进行修改和查看。

# ***总结：***

&nbsp;	学习这个demo更多的是让我在学习过程中停顿下来，总结梳理Unity中的基础部分，最大的收获是了解了demo的一种设计思路，这些事件驱动的思想真的让我

受益匪浅，直接将一些现实生活中难以描述的逻辑变得有序，可编写起来，真是站在巨人的肩膀上了，希望以后能将这些coding思想为我所用，加油吧！

&nbsp;	

